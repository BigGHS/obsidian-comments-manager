/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  COMMENTS_VIEW_TYPE: () => COMMENTS_VIEW_TYPE,
  default: () => CommentsManagerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  commentPrefix: "%%",
  openOnStart: true,
  debugMode: false,
  defaultCollapsed: true
};
var COMMENTS_VIEW_TYPE = "comments-manager-view";
var CommentsManagerPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.refreshTimeout = null;
    this.skipNextRefresh = false;
    // Made public so CommentsView can access it
    this.allHeaders = [];
  }
  debug(message, ...args) {
    if (this.settings.debugMode) {
      console.log(`[Comments Manager] ${message}`, ...args);
    }
  }
  async onload() {
    await this.loadSettings();
    this.registerView(
      COMMENTS_VIEW_TYPE,
      (leaf) => new CommentsView(leaf, this)
    );
    this.addRibbonIcon("percent", "Toggle Comments Panel", () => {
      this.activateView();
    });
    this.addCommand({
      id: "toggle-comments-panel",
      name: "Toggle Comments Panel",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "insert-comment",
      name: "Insert comment",
      editorCallback: (editor, view) => {
        const selection = editor.getSelection();
        const comment = `${this.settings.commentPrefix} ${selection || "Your comment here"} ${this.settings.commentPrefix}`;
        editor.replaceSelection(comment);
        this.refreshCommentsView();
      }
    });
    this.addSettingTab(new CommentsManagerSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.refreshCommentsView();
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-change", () => {
        this.debounceRefresh();
      })
    );
    if (this.settings.openOnStart) {
      this.app.workspace.onLayoutReady(() => {
        this.activateView();
      });
    }
  }
  debounceRefresh() {
    this.debug("debounceRefresh called, skipNextRefresh:", this.skipNextRefresh);
    if (this.skipNextRefresh) {
      this.debug("Skipping refresh due to skipNextRefresh flag");
      this.skipNextRefresh = false;
      return;
    }
    if (this.refreshTimeout) {
      window.clearTimeout(this.refreshTimeout);
    }
    this.refreshTimeout = window.setTimeout(() => {
      this.debug("Executing delayed refresh");
      this.refreshCommentsView();
    }, 500);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(COMMENTS_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
      workspace.revealLeaf(leaf);
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: COMMENTS_VIEW_TYPE, active: true });
      }
    }
    this.refreshCommentsView();
  }
  refreshCommentsView() {
    const leaves = this.app.workspace.getLeavesOfType(COMMENTS_VIEW_TYPE);
    leaves.forEach((leaf) => {
      if (leaf.view instanceof CommentsView) {
        leaf.view.refresh();
      }
    });
  }
  extractComments(content) {
    const lines = content.split("\n");
    const comments = [];
    const commentRegex = new RegExp(`${this.escapeRegex(this.settings.commentPrefix)}(.*?)${this.escapeRegex(this.settings.commentPrefix)}`, "g");
    let currentPos = 0;
    lines.forEach((line, lineIndex) => {
      const lineStartPos = currentPos;
      let match;
      commentRegex.lastIndex = 0;
      while ((match = commentRegex.exec(line)) !== null) {
        comments.push({
          text: match[1].trim(),
          line: lineIndex,
          startPos: lineStartPos + match.index,
          endPos: lineStartPos + match.index + match[0].length,
          fullMatch: match[0]
        });
      }
      currentPos += line.length + 1;
    });
    return comments;
  }
  extractHeaders(content) {
    const lines = content.split("\n");
    const headers = [];
    const headerRegex = /^(#{1,6})\s+(.+)$/;
    lines.forEach((line, lineIndex) => {
      const match = headerRegex.exec(line.trim());
      if (match) {
        headers.push({
          text: match[2].trim(),
          level: match[1].length,
          line: lineIndex
        });
      }
    });
    return headers;
  }
  groupCommentsByHeaders(comments, headers) {
    this.allHeaders = headers;
    const groups = [];
    const sortedHeaders = [...headers].sort((a, b) => a.line - b.line);
    comments.forEach((comment) => {
      let nearestHeader = null;
      for (let i = sortedHeaders.length - 1; i >= 0; i--) {
        if (sortedHeaders[i].line < comment.line) {
          nearestHeader = sortedHeaders[i];
          break;
        }
      }
      let group = groups.find(
        (g) => g.header === null && nearestHeader === null || g.header !== null && nearestHeader !== null && g.header.line === nearestHeader.line
      );
      if (!group) {
        group = {
          header: nearestHeader,
          comments: []
        };
        groups.push(group);
      }
      group.comments.push(comment);
    });
    groups.sort((a, b) => {
      if (a.header === null && b.header === null) return 0;
      if (a.header === null) return -1;
      if (b.header === null) return 1;
      return a.header.line - b.header.line;
    });
    return this.buildHierarchicalGroups(groups);
  }
  buildHierarchicalGroups(flatGroups) {
    const commentGroupsByHeaderLine = /* @__PURE__ */ new Map();
    let noHeaderGroup = null;
    flatGroups.forEach((group) => {
      if (group.header) {
        commentGroupsByHeaderLine.set(group.header.line, group);
      } else {
        noHeaderGroup = group;
      }
    });
    const allGroups = [];
    if (noHeaderGroup) {
      allGroups.push(noHeaderGroup);
    }
    const sortedHeaders = this.allHeaders.sort((a, b) => a.line - b.line);
    sortedHeaders.forEach((header) => {
      const existingGroup = commentGroupsByHeaderLine.get(header.line);
      if (existingGroup) {
        allGroups.push(existingGroup);
      } else {
        allGroups.push({
          header,
          comments: []
        });
      }
    });
    const result = [];
    const stack = [];
    for (const group of allGroups) {
      if (!group.header) {
        result.push(group);
        continue;
      }
      while (stack.length > 0 && stack[stack.length - 1].header.level >= group.header.level) {
        stack.pop();
      }
      if (stack.length > 0) {
        const parent = stack[stack.length - 1];
        if (!parent.children) {
          parent.children = [];
        }
        parent.children.push(group);
        group.parent = parent;
      } else {
        result.push(group);
      }
      stack.push(group);
    }
    return result;
  }
  hasDescendantComments(header, commentGroupsByHeaderLine) {
    return this.allHeaders.some(
      (otherHeader) => otherHeader.line > header.line && otherHeader.level > header.level && commentGroupsByHeaderLine.has(otherHeader.line)
    );
  }
  escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  highlightCommentInEditor(comment) {
    this.debug("highlightCommentInEditor called", comment);
    const file = this.app.workspace.getActiveFile();
    if (!file) {
      new import_obsidian.Notice("No active markdown file");
      return;
    }
    this.app.workspace.getLeaf().openFile(file).then(() => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView) return;
      const editor = activeView.editor;
      const content = editor.getValue();
      const comments = this.extractComments(content);
      let match = comments.find(
        (c) => c.text === comment.text && c.line === comment.line && c.startPos === comment.startPos
      );
      if (!match) {
        match = comments.find(
          (c) => c.text === comment.text && Math.abs(c.line - comment.line) <= 2
        );
      }
      const target = match || comment;
      this.debug("Found target comment:", target);
      const line = editor.getLine(target.line);
      const commentStartInLine = line.indexOf(target.fullMatch);
      let startCh = 0;
      let endCh = line.length;
      if (commentStartInLine !== -1) {
        const prefixLength = this.settings.commentPrefix.length + 1;
        startCh = commentStartInLine + prefixLength;
        endCh = commentStartInLine + target.fullMatch.length - prefixLength;
      }
      editor.setSelection(
        { line: target.line, ch: startCh },
        { line: target.line, ch: endCh }
      );
      editor.scrollIntoView(
        { from: { line: target.line, ch: startCh }, to: { line: target.line, ch: endCh } },
        true
      );
      editor.focus();
    });
    this.debug("Setting skipNextRefresh to true");
    this.skipNextRefresh = true;
    setTimeout(() => {
      this.debug("Clearing skipNextRefresh");
      this.skipNextRefresh = false;
    }, 200);
  }
  highlightHeaderInEditor(header) {
    this.debug("highlightHeaderInEditor called", header);
    const file = this.app.workspace.getActiveFile();
    if (!file) {
      new import_obsidian.Notice("No active markdown file");
      return;
    }
    this.app.workspace.getLeaf().openFile(file).then(() => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView) return;
      const editor = activeView.editor;
      const headers = this.extractHeaders(editor.getValue());
      const match = headers.find((h) => h.text === header.text && h.level === header.level);
      if (!match) return;
      editor.setCursor({ line: match.line, ch: 0 });
      editor.scrollIntoView({ from: { line: match.line, ch: 0 }, to: { line: match.line, ch: 0 } }, true);
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var CommentsView = class extends import_obsidian.ItemView {
  // Track if user manually expanded sections
  constructor(leaf, plugin) {
    super(leaf);
    this.currentFile = null;
    this.renderedGroups = [];
    this.isCollapsed = false;
    // Will be set from settings
    this.hasManualExpansions = false;
    this.plugin = plugin;
    this.isCollapsed = plugin.settings.defaultCollapsed;
  }
  debug(message, ...args) {
    if (this.plugin.settings.debugMode) {
      console.log(`[Comments View] ${message}`, ...args);
    }
  }
  getViewType() {
    return COMMENTS_VIEW_TYPE;
  }
  getDisplayText() {
    return "Comments";
  }
  getIcon() {
    return "percent";
  }
  async onOpen() {
    this.refresh();
  }
  async onClose() {
  }
  refresh() {
    this.debug("CommentsView.refresh called");
    const container = this.containerEl.children[1];
    container.empty();
    const header = container.createEl("div", { cls: "comments-header" });
    const titleRow = header.createEl("div", { cls: "comments-title-row" });
    titleRow.createEl("h4", { text: "Comments", cls: "comments-title" });
    const toggleAllBtn = titleRow.createEl("button", {
      cls: "comments-toggle-btn",
      attr: { title: "Toggle collapse/expand all sections" }
    });
    const toggleIcon = toggleAllBtn.createEl("span", { cls: "comments-toggle-icon" });
    toggleIcon.innerHTML = this.isCollapsed ? "+" : "-";
    const spacer = titleRow.createEl("div", { cls: "comments-spacer" });
    const searchContainer = header.createEl("div", { cls: "comments-search-container" });
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      cls: "comments-search-input",
      attr: {
        placeholder: "Search comments...",
        spellcheck: "false"
      }
    });
    const clearSearchBtn = searchContainer.createEl("button", {
      cls: "comments-clear-search",
      attr: { title: "Clear search" }
    });
    clearSearchBtn.innerHTML = "\xD7";
    setTimeout(() => {
      this.debug("Executing delayed refresh check");
      let activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      let currentFile = this.app.workspace.getActiveFile();
      this.debug("Active view:", !!activeView, "Current file:", !!currentFile);
      if (!activeView && currentFile) {
        const leaves = this.app.workspace.getLeavesOfType("markdown");
        for (const leaf of leaves) {
          const view = leaf.view;
          if (view.file === currentFile) {
            activeView = view;
            this.debug("Found view for current file");
            break;
          }
        }
      }
      if (!activeView && this.currentFile) {
        this.debug("Using stored current file");
        currentFile = this.currentFile;
      }
      if (!activeView && !currentFile) {
        this.debug("No active markdown view or file found");
        container.createEl("div", {
          text: "No active markdown file",
          cls: "comments-empty"
        });
        toggleAllBtn.disabled = true;
        return;
      }
      if (currentFile) {
        this.currentFile = currentFile;
      }
      this.debug("Getting file content");
      let content = "";
      if (activeView) {
        content = activeView.editor.getValue();
        this.debug("Got content from active view");
        this.processComments(content, container, toggleAllBtn, toggleIcon, searchInput, clearSearchBtn);
      } else if (currentFile) {
        this.app.vault.read(currentFile).then((fileContent) => {
          this.debug("Got content from file read");
          this.processComments(fileContent, container, toggleAllBtn, toggleIcon, searchInput, clearSearchBtn);
        });
      }
    }, 10);
  }
  processComments(content, container, toggleBtn, toggleIcon, searchInput, clearSearchBtn) {
    this.debug("Processing comments for content of length:", content.length);
    const currentStates = /* @__PURE__ */ new Map();
    this.renderedGroups.forEach((rendered) => {
      if (rendered.group.header) {
        const key = `${rendered.group.header.level}-${rendered.group.header.text}`;
        currentStates.set(key, !rendered.group.isCollapsed);
      }
    });
    this.renderedGroups = [];
    const comments = this.plugin.extractComments(content);
    const headers = this.plugin.extractHeaders(content);
    const commentGroups = this.plugin.groupCommentsByHeaders(comments, headers);
    this.debug("Found", comments.length, "comments in", commentGroups.length, "groups");
    if (comments.length === 0) {
      container.createEl("div", {
        text: "No comments found",
        cls: "comments-empty"
      });
      if (toggleBtn) toggleBtn.disabled = true;
      if (searchInput) searchInput.disabled = true;
      return;
    }
    if (toggleBtn) toggleBtn.disabled = false;
    if (searchInput) searchInput.disabled = false;
    const commentsList = container.createEl("div", { cls: "comments-list" });
    const allGroups = [];
    const collectAllGroups = (groups) => {
      groups.forEach((group) => {
        allGroups.push(group);
        if (group.children) {
          collectAllGroups(group.children);
        }
      });
    };
    collectAllGroups(commentGroups);
    if (toggleBtn && toggleIcon) {
      toggleBtn.onclick = (e) => {
        this.debug("Toggle button clicked, current state:", this.isCollapsed);
        e.preventDefault();
        e.stopPropagation();
        this.toggleAllGroups(toggleIcon);
      };
      this.updateToggleButton(toggleIcon);
    }
    if (searchInput && clearSearchBtn) {
      let searchTimeout = null;
      let currentSearchTerm = "";
      const performSearch = () => {
        const searchTerm = searchInput.value.toLowerCase().trim();
        currentSearchTerm = searchTerm;
        this.filterComments(commentsList, commentGroups, searchTerm);
        if (searchTerm) {
          clearSearchBtn.style.display = "block";
        } else {
          clearSearchBtn.style.display = "none";
        }
      };
      this.currentSearchTerm = "";
      searchInput.addEventListener("input", () => {
        if (searchTimeout) {
          window.clearTimeout(searchTimeout);
        }
        searchTimeout = window.setTimeout(() => {
          this.currentSearchTerm = searchInput.value.toLowerCase().trim();
          performSearch();
        }, 300);
      });
      clearSearchBtn.addEventListener("click", () => {
        searchInput.value = "";
        this.currentSearchTerm = "";
        performSearch();
        searchInput.focus();
      });
      clearSearchBtn.style.display = "none";
    }
    commentGroups.forEach((group) => {
      if (this.isCollapsed && !this.hasManualExpansions) {
        this.setGroupCollapsedRecursively(group, true);
      }
      this.renderCommentGroup(group, commentsList, 0);
    });
    if (this.hasManualExpansions && currentStates.size > 0) {
      this.restoreExpansionStates(commentGroups, currentStates);
    }
    this.debug("Rendered groups count:", this.renderedGroups.length);
    this.debug("Initial collapsed state:", this.isCollapsed, "hasManualExpansions:", this.hasManualExpansions);
  }
  restoreExpansionStates(groups, states) {
    const restoreGroup = (group) => {
      if (group.header) {
        const key = `${group.header.level}-${group.header.text}`;
        const wasExpanded = states.get(key);
        if (wasExpanded !== void 0) {
          group.isCollapsed = !wasExpanded;
          const rendered = this.renderedGroups.find(
            (r) => r.group.header && r.group.header.level === group.header.level && r.group.header.text === group.header.text
          );
          if (rendered) {
            rendered.collapseIcon.textContent = group.isCollapsed ? "\u25B6" : "\u25BC";
            rendered.contentElement.style.display = group.isCollapsed ? "none" : "block";
          }
        }
      }
      if (group.children) {
        group.children.forEach(restoreGroup);
      }
    };
    groups.forEach(restoreGroup);
  }
  setGroupCollapsedRecursively(group, collapsed) {
    group.isCollapsed = collapsed;
    if (group.children) {
      group.children.forEach((child) => {
        this.setGroupCollapsedRecursively(child, collapsed);
      });
    }
  }
  highlightSearchText(text, searchTerm) {
    if (!searchTerm) return text;
    const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")})`, "gi");
    return text.replace(regex, '<mark class="search-highlight">$1</mark>');
  }
  filterComments(commentsList, commentGroups, searchTerm) {
    commentsList.empty();
    if (!searchTerm) {
      commentGroups.forEach((group) => {
        this.renderCommentGroup(group, commentsList, 0);
      });
      return;
    }
    const filteredGroups = this.filterGroupsRecursively(commentGroups, searchTerm);
    if (filteredGroups.length === 0) {
      commentsList.createEl("div", {
        text: "No matching comments found",
        cls: "comments-empty"
      });
      return;
    }
    filteredGroups.forEach((group) => {
      this.renderCommentGroup(group, commentsList, 0);
    });
  }
  filterGroupsRecursively(groups, searchTerm) {
    const filtered = [];
    groups.forEach((group) => {
      var _a;
      const headerMatches = ((_a = group.header) == null ? void 0 : _a.text.toLowerCase().includes(searchTerm)) || false;
      const matchingComments = group.comments.filter(
        (comment) => comment.text.toLowerCase().includes(searchTerm)
      );
      const filteredChildren = group.children ? this.filterGroupsRecursively(group.children, searchTerm) : [];
      if (headerMatches || matchingComments.length > 0 || filteredChildren.length > 0) {
        const filteredGroup = {
          header: group.header,
          comments: headerMatches ? group.comments : matchingComments,
          children: filteredChildren.length > 0 ? filteredChildren : void 0,
          parent: group.parent,
          isCollapsed: false
          // Expand all when searching to show results
        };
        filtered.push(filteredGroup);
      }
    });
    return filtered;
  }
  renderCommentGroup(group, container, depth) {
    const headerSection = container.createEl("div", { cls: "comment-header-section" });
    headerSection.style.marginLeft = `${depth * 12}px`;
    const headerEl = headerSection.createEl("div", { cls: "comment-header" });
    const collapseIcon = headerEl.createEl("span", { cls: "comment-collapse-icon" });
    const hasChildren = group.children && group.children.length > 0 || group.comments.length > 0;
    if (hasChildren) {
      collapseIcon.textContent = group.isCollapsed ? "\u25B6" : "\u25BC";
      collapseIcon.style.visibility = "visible";
    } else {
      collapseIcon.style.visibility = "hidden";
    }
    const headerText = headerEl.createEl("span", { cls: "comment-header-text" });
    if (group.header) {
      const totalComments = this.countTotalComments(group);
      if (totalComments > 0) {
        headerText.textContent = `${group.header.text} (${totalComments})`;
      } else {
        headerText.textContent = group.header.text;
      }
    } else {
      headerText.textContent = `No Header (${group.comments.length})`;
    }
    const groupContent = headerSection.createEl("div", { cls: "comment-group-content" });
    if (group.isCollapsed) {
      groupContent.style.display = "none";
    }
    if (hasChildren) {
      this.renderedGroups.push({
        group,
        collapseIcon,
        contentElement: groupContent
      });
    }
    if (hasChildren) {
      collapseIcon.addEventListener("click", (e) => {
        var _a;
        this.debug("Collapse icon clicked for group:", ((_a = group.header) == null ? void 0 : _a.text) || "No Header");
        e.preventDefault();
        e.stopPropagation();
        this.toggleGroupCollapse(group, collapseIcon, groupContent);
      });
    }
    if (group.header) {
      headerText.addEventListener("click", (e) => {
        this.debug("Header text clicked, navigating to:", group.header.text);
        e.preventDefault();
        e.stopPropagation();
        this.plugin.skipNextRefresh = true;
        this.plugin.highlightHeaderInEditor(group.header);
        setTimeout(() => {
          this.plugin.skipNextRefresh = false;
        }, 100);
        return false;
      });
      headerEl.addEventListener("click", (e) => {
        if (e.target === collapseIcon || e.target === headerText) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
    }
    if (group.comments.length > 0) {
      const groupComments = groupContent.createEl("div", { cls: "comment-group-comments" });
      group.comments.forEach((comment) => {
        this.createCommentElement(comment, groupComments);
      });
    }
    if (group.children) {
      group.children.forEach((childGroup) => {
        this.renderCommentGroup(childGroup, groupContent, depth + 1);
      });
    }
  }
  countTotalComments(group) {
    let total = group.comments.length;
    if (group.children) {
      group.children.forEach((child) => {
        total += this.countTotalComments(child);
      });
    }
    return total;
  }
  toggleGroupCollapse(group, icon, content) {
    group.isCollapsed = !group.isCollapsed;
    if (group.isCollapsed) {
      icon.textContent = "\u25B6";
      content.style.display = "none";
    } else {
      icon.textContent = "\u25BC";
      content.style.display = "block";
      this.hasManualExpansions = true;
    }
    if (group.isCollapsed && group.children) {
      this.collapseAllChildren(group);
    }
    this.debug("Group toggled, hasManualExpansions:", this.hasManualExpansions);
  }
  toggleAllGroups(toggleIcon) {
    this.debug("toggleAllGroups called, current state:", this.isCollapsed);
    if (this.isCollapsed) {
      this.debug("Expanding all groups");
      this.expandAllGroups([]);
      this.hasManualExpansions = false;
    } else {
      this.debug("Collapsing all groups to top level overview");
      this.collapseAllGroups([]);
      this.hasManualExpansions = false;
    }
    this.isCollapsed = !this.isCollapsed;
    this.updateToggleButton(toggleIcon);
    this.debug("toggleAllGroups completed, new state:", this.isCollapsed);
  }
  updateToggleButton(toggleIcon) {
    if (this.isCollapsed) {
      toggleIcon.innerHTML = "+";
      toggleIcon.parentElement.setAttribute("title", "Expand all sections");
    } else {
      toggleIcon.innerHTML = "-";
      toggleIcon.parentElement.setAttribute("title", "Collapse all sections");
    }
  }
  collapseAllGroups(allGroups) {
    this.debug("Collapsing all groups to top level overview");
    this.renderedGroups.forEach((rendered) => {
      const hasContent = rendered.group.children && rendered.group.children.length > 0 || rendered.group.comments.length > 0;
      if (hasContent) {
        rendered.group.isCollapsed = true;
        rendered.collapseIcon.textContent = "\u25B6";
        rendered.contentElement.style.display = "none";
      }
    });
  }
  expandAllGroups(allGroups) {
    this.debug("Expanding all groups");
    this.renderedGroups.forEach((rendered) => {
      rendered.group.isCollapsed = false;
      rendered.collapseIcon.textContent = "\u25BC";
      rendered.contentElement.style.display = "block";
    });
  }
  collapseAllChildren(group) {
    if (group.children) {
      group.children.forEach((child) => {
        child.isCollapsed = true;
        this.collapseAllChildren(child);
      });
    }
  }
  createCommentElement(comment, container) {
    const commentEl = container.createEl("div", { cls: "comment-item" });
    const contentEl = commentEl.createEl("div", { cls: "comment-content" });
    const textEl = contentEl.createEl("div", {
      cls: "comment-text",
      attr: { contenteditable: "true", spellcheck: "false" }
    });
    const currentSearchTerm = this.currentSearchTerm || "";
    if (currentSearchTerm && comment.text.toLowerCase().includes(currentSearchTerm)) {
      textEl.innerHTML = this.highlightSearchText(comment.text || "(empty comment)", currentSearchTerm);
    } else {
      textEl.textContent = comment.text || "(empty comment)";
    }
    const lineEl = contentEl.createEl("div", {
      text: `Line ${comment.line + 1}`,
      cls: "comment-line"
    });
    const actionsEl = commentEl.createEl("div", { cls: "comment-actions" });
    const saveBtn = actionsEl.createEl("button", {
      text: "Save",
      cls: "comment-btn comment-save-btn"
    });
    saveBtn.style.display = "none";
    const cancelBtn = actionsEl.createEl("button", {
      text: "Cancel",
      cls: "comment-btn comment-cancel-btn"
    });
    cancelBtn.style.display = "none";
    const deleteBtn = actionsEl.createEl("button", {
      text: "\xD7",
      cls: "comment-btn comment-delete-btn",
      attr: { title: "Delete comment" }
    });
    let originalText = comment.text;
    let isEditing = false;
    textEl.addEventListener("input", () => {
      if (!isEditing) {
        isEditing = true;
        saveBtn.style.display = "inline-block";
        cancelBtn.style.display = "inline-block";
        deleteBtn.style.display = "none";
        commentEl.addClass("comment-editing");
        textEl.innerHTML = "";
        textEl.textContent = originalText;
      }
    });
    textEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        saveComment();
      } else if (e.key === "Escape") {
        e.preventDefault();
        cancelEdit();
      }
    });
    const saveComment = () => {
      var _a;
      const newText = ((_a = textEl.textContent) == null ? void 0 : _a.trim()) || "";
      if (newText !== originalText) {
        this.updateCommentInEditor(comment, newText);
        originalText = newText;
      }
      exitEditMode();
    };
    const cancelEdit = () => {
      if (currentSearchTerm && originalText.toLowerCase().includes(currentSearchTerm)) {
        textEl.innerHTML = this.highlightSearchText(originalText, currentSearchTerm);
      } else {
        textEl.textContent = originalText;
      }
      exitEditMode();
    };
    const exitEditMode = () => {
      isEditing = false;
      saveBtn.style.display = "none";
      cancelBtn.style.display = "none";
      deleteBtn.style.display = "inline-block";
      commentEl.removeClass("comment-editing");
      textEl.blur();
    };
    saveBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      saveComment();
    });
    cancelBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      cancelEdit();
    });
    deleteBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const confirmDelete = confirm(`Are you sure you want to delete this comment?

"${comment.text}"`);
      if (confirmDelete) {
        this.deleteCommentFromEditor(comment);
      }
    });
    commentEl.addEventListener("click", (e) => {
      this.debug("Comment clicked, isEditing:", isEditing, "target:", e.target);
      if (isEditing) return;
      const target = e.target;
      if (target.tagName === "BUTTON" || target.closest("button")) {
        this.debug("Click was on button, ignoring");
        return;
      }
      if (target === textEl) {
        this.debug("Clicked on text element, entering edit mode");
        e.preventDefault();
        e.stopPropagation();
        isEditing = true;
        saveBtn.style.display = "inline-block";
        cancelBtn.style.display = "inline-block";
        deleteBtn.style.display = "none";
        commentEl.addClass("comment-editing");
        textEl.focus();
        const range = document.createRange();
        range.selectNodeContents(textEl);
        const selection = window.getSelection();
        if (selection) {
          selection.removeAllRanges();
          selection.addRange(range);
        }
        return;
      }
      this.debug("Calling highlightCommentInEditor");
      e.preventDefault();
      e.stopPropagation();
      this.plugin.skipNextRefresh = true;
      this.plugin.highlightCommentInEditor(comment);
      setTimeout(() => {
        this.plugin.skipNextRefresh = false;
      }, 300);
    });
    commentEl.addEventListener("mouseleave", () => {
      commentEl.removeClass("comment-item-hover");
    });
  }
  updateCommentInEditor(comment, newText) {
    this.debug("updateCommentInEditor called with:", newText);
    let activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    let currentFile = this.app.workspace.getActiveFile();
    this.debug("Active view:", !!activeView, "Current file:", !!currentFile);
    if (!activeView && currentFile) {
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view.file === currentFile) {
          activeView = view;
          this.debug("Found view for current file in update");
          break;
        }
      }
    }
    if (!activeView && this.currentFile) {
      this.debug("Using stored current file for update");
      currentFile = this.currentFile;
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view.file === currentFile) {
          activeView = view;
          this.debug("Found view for stored file in update");
          break;
        }
      }
    }
    if (!activeView) {
      this.debug("No active view found for updating comment");
      return;
    }
    this.debug("Found active view, proceeding with update");
    const editor = activeView.editor;
    const currentContent = editor.getValue();
    this.debug("Current content length:", currentContent.length);
    this.debug("Original comment:", comment);
    const currentComments = this.plugin.extractComments(currentContent);
    const matchingComment = currentComments.find(
      (c) => c.text === comment.text && c.line === comment.line
    );
    if (!matchingComment) {
      this.debug("Could not find matching comment in current content");
      const textMatch = currentComments.find((c) => c.text === comment.text);
      if (textMatch) {
        this.debug("Found comment by text match");
        this.performCommentUpdate(editor, textMatch, newText);
      } else {
        this.debug("Comment not found, it may have been deleted");
        this.refresh();
      }
      return;
    }
    this.debug("Found matching comment with current positions:", matchingComment);
    this.performCommentUpdate(editor, matchingComment, newText);
  }
  performCommentUpdate(editor, comment, newText) {
    const content = editor.getValue();
    const beforeComment = content.substring(0, comment.startPos);
    const afterComment = content.substring(comment.endPos);
    const newComment = `${this.plugin.settings.commentPrefix} ${newText} ${this.plugin.settings.commentPrefix}`;
    this.debug("Replacing comment at positions", comment.startPos, "-", comment.endPos);
    this.debug("Old comment:", comment.fullMatch);
    this.debug("New comment:", newComment);
    const newContent = beforeComment + newComment + afterComment;
    editor.setValue(newContent);
    new import_obsidian.Notice("Comment updated");
    setTimeout(() => {
      this.debug("Refreshing view after comment update");
      this.refresh();
    }, 100);
  }
  deleteCommentFromEditor(comment) {
    this.debug("deleteCommentFromEditor called for:", comment);
    let activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    let currentFile = this.app.workspace.getActiveFile();
    this.debug("Delete - Active view:", !!activeView, "Current file:", !!currentFile);
    if (!activeView && currentFile) {
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view.file === currentFile) {
          activeView = view;
          this.debug("Found view for current file in delete");
          break;
        }
      }
    }
    if (!activeView && this.currentFile) {
      this.debug("Using stored current file for delete");
      currentFile = this.currentFile;
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view.file === currentFile) {
          activeView = view;
          this.debug("Found view for stored file in delete");
          break;
        }
      }
    }
    if (!activeView) {
      this.debug("No active view found for deleting comment");
      return;
    }
    const editor = activeView.editor;
    const currentContent = editor.getValue();
    const currentComments = this.plugin.extractComments(currentContent);
    const matchingComment = currentComments.find(
      (c) => c.text === comment.text && c.line === comment.line
    );
    if (!matchingComment) {
      this.debug("Could not find matching comment to delete");
      this.refresh();
      return;
    }
    this.debug("Deleting comment at positions", matchingComment.startPos, "-", matchingComment.endPos);
    const lines = currentContent.split("\n");
    const commentLine = lines[matchingComment.line];
    this.debug("Original line:", commentLine);
    const commentPattern = new RegExp(this.plugin.escapeRegex(matchingComment.fullMatch), "g");
    const cleanedLine = commentLine.replace(commentPattern, "");
    this.debug("Cleaned line:", cleanedLine);
    lines[matchingComment.line] = cleanedLine;
    const newContent = lines.join("\n");
    const finalContent = newContent.replace(/  +/g, " ");
    editor.setValue(finalContent);
    new import_obsidian.Notice("Comment deleted");
    setTimeout(() => {
      this.debug("Refreshing view after comment deletion");
      this.refresh();
    }, 100);
  }
};
var CommentsManagerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Comments Manager Settings" });
    new import_obsidian.Setting(containerEl).setName("Comment prefix").setDesc("The characters used to mark comments (e.g., %% for Obsidian comments)").addText((text) => text.setPlaceholder("%%").setValue(this.plugin.settings.commentPrefix).onChange(async (value) => {
      this.plugin.settings.commentPrefix = value || "%%";
      await this.plugin.saveSettings();
      this.plugin.refreshCommentsView();
    }));
    new import_obsidian.Setting(containerEl).setName("Open panel on startup").setDesc("Automatically open the comments panel when Obsidian starts").addToggle((toggle) => toggle.setValue(this.plugin.settings.openOnStart).onChange(async (value) => {
      this.plugin.settings.openOnStart = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default collapsed view").setDesc("Start with comments panel in collapsed state (showing only headers)").addToggle((toggle) => toggle.setValue(this.plugin.settings.defaultCollapsed).onChange(async (value) => {
      this.plugin.settings.defaultCollapsed = value;
      await this.plugin.saveSettings();
      this.plugin.refreshCommentsView();
    }));
    new import_obsidian.Setting(containerEl).setName("Debug mode").setDesc("Enable debug logging in the developer console (for troubleshooting)").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
      this.plugin.settings.debugMode = value;
      await this.plugin.saveSettings();
    }));
  }
};
