/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  COMMENTS_VIEW_TYPE: () => COMMENTS_VIEW_TYPE,
  default: () => CommentsManagerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  commentPrefix: "%%",
  openOnStart: true,
  debugMode: false,
  defaultCollapsed: true,
  defaultViewMode: "outliner",
  // Print Mode defaults
  printModeCalloutType: "comment",
  includeCommentAuthor: false,
  includeCommentTimestamp: false
};
var COMMENTS_VIEW_TYPE = "comments-manager-view";
var PrintModePreviewModal = class extends import_obsidian.Modal {
  constructor(app, plugin, originalContent, convertedContent, activeView) {
    super(app);
    this.plugin = plugin;
    this.originalContent = originalContent;
    this.convertedContent = convertedContent;
    this.activeView = activeView;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Print Mode Preview" });
    const desc = contentEl.createEl("p", { cls: "print-mode-description" });
    desc.innerHTML = "This preview shows how your document will look with comments converted to callouts for printing/PDF export. The original document will not be modified.";
    const previewContainer = contentEl.createEl("div", { cls: "print-mode-preview-container" });
    const previewEl = previewContainer.createEl("pre", { cls: "print-mode-preview" });
    previewEl.textContent = this.convertedContent;
    const buttonContainer = contentEl.createEl("div", { cls: "print-mode-buttons" });
    const exportBtn = buttonContainer.createEl("button", {
      text: "Export to PDF",
      cls: "mod-cta"
    });
    const copyBtn = buttonContainer.createEl("button", {
      text: "Copy Content"
    });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    exportBtn.onclick = () => {
      this.triggerPDFExport();
    };
    copyBtn.onclick = () => {
      navigator.clipboard.writeText(this.convertedContent);
      new import_obsidian.Notice("Converted content copied to clipboard");
    };
    cancelBtn.onclick = () => {
      this.close();
    };
  }
  async triggerPDFExport() {
    if (!this.activeView) {
      new import_obsidian.Notice("No active markdown view available");
      return;
    }
    const editor = this.activeView.editor;
    if (!editor) {
      new import_obsidian.Notice("Editor is no longer available");
      return;
    }
    const originalContent = editor.getValue();
    try {
      this.close();
      await new Promise((resolve) => setTimeout(resolve, 200));
      this.activeView.editor.focus();
      editor.setValue(this.convertedContent);
      editor.refresh();
      await new Promise((resolve) => setTimeout(resolve, 800));
      const restoreContent = () => {
        editor.setValue(originalContent);
        editor.refresh();
        new import_obsidian.Notice("Original content restored");
      };
      const notice = new import_obsidian.Notice("Document converted to callouts! Now use Ctrl+P or File \u2192 Export to PDF. Click here when done to restore original content.", 0);
      notice.noticeEl.style.cursor = "pointer";
      notice.noticeEl.addEventListener("click", () => {
        restoreContent();
        notice.hide();
      });
      const restoreCommand = this.plugin.addCommand({
        id: "restore-original-content",
        name: "Restore Original Content (after Print Mode)",
        callback: () => {
          restoreContent();
          notice.hide();
          this.plugin.removeCommand("restore-original-content");
        }
      });
    } catch (error) {
      console.error("Error during PDF export preparation:", error);
      new import_obsidian.Notice("Error preparing for PDF export: " + error.message);
      try {
        editor.setValue(originalContent);
        editor.refresh();
      } catch (restoreError) {
        console.error("Error restoring content:", restoreError);
      }
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var CommentConversionModal = class extends import_obsidian.Modal {
  constructor(app, comment, onConfirm) {
    super(app);
    this.comment = comment;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Convert Comment to Callout" });
    const previewContainer = contentEl.createEl("div", { cls: "conversion-modal-preview" });
    previewContainer.createEl("h4", { text: "Comment:" });
    const commentPreview = previewContainer.createEl("div", { cls: "conversion-modal-comment" });
    commentPreview.textContent = this.comment.text.length > 200 ? this.comment.text.substring(0, 200) + "..." : this.comment.text;
    const titleContainer = contentEl.createEl("div", { cls: "conversion-modal-title-container" });
    titleContainer.createEl("label", {
      text: 'Callout Title (leave blank for "Comment"):',
      cls: "conversion-modal-label"
    });
    const titleInput = titleContainer.createEl("input", {
      type: "text",
      cls: "conversion-modal-input",
      attr: {
        placeholder: 'e.g., "Important Note", "Question", "Suggestion"...',
        spellcheck: "false"
      }
    });
    const infoEl = contentEl.createEl("p", { cls: "conversion-modal-info" });
    infoEl.innerHTML = "<strong>Note:</strong> This will permanently replace the comment with a visible callout. This action cannot be undone.";
    const buttonContainer = contentEl.createEl("div", { cls: "conversion-modal-buttons" });
    const convertBtn = buttonContainer.createEl("button", {
      text: "Convert to Callout",
      cls: "mod-cta"
    });
    const cancelBtn = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    convertBtn.onclick = () => {
      const customTitle = titleInput.value.trim();
      this.onConfirm(customTitle);
      this.close();
    };
    cancelBtn.onclick = () => {
      this.close();
    };
    titleInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        convertBtn.click();
      } else if (e.key === "Escape") {
        e.preventDefault();
        cancelBtn.click();
      }
    });
    setTimeout(() => titleInput.focus(), 100);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var CommentsManagerPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.refreshTimeout = null;
    this.skipNextRefresh = false;
    this.allHeaders = [];
  }
  debug(message, ...args) {
    if (this.settings.debugMode) {
      console.log(`[Comments Manager] ${message}`, ...args);
    }
  }
  async onload() {
    await this.loadSettings();
    this.registerView(
      COMMENTS_VIEW_TYPE,
      (leaf) => new CommentsView(leaf, this)
    );
    this.addRibbonIcon("percent", "Toggle Comments Panel", () => {
      this.activateView();
    });
    this.addCommand({
      id: "toggle-comments-panel",
      name: "Toggle Comments Panel",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "insert-comment",
      name: "Insert comment",
      editorCallback: (editor, view) => {
        const selection = editor.getSelection();
        const comment = `${this.settings.commentPrefix} ${selection || "Your comment here"} ${this.settings.commentPrefix}`;
        editor.replaceSelection(comment);
        this.refreshCommentsView();
      }
    });
    this.addCommand({
      id: "activate-print-mode",
      name: "Activate Print Mode (Convert Comments to Callouts)",
      callback: () => {
        this.activatePrintMode();
      }
    });
    this.addSettingTab(new CommentsManagerSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.refreshCommentsView();
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-change", () => {
        this.debounceRefresh();
      })
    );
    if (this.settings.openOnStart) {
      this.app.workspace.onLayoutReady(() => {
        this.activateView();
      });
    }
  }
  activatePrintMode() {
    let activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    let currentFile = this.app.workspace.getActiveFile();
    this.debug("Print Mode - Active view:", !!activeView, "Current file:", !!currentFile);
    if (!activeView && currentFile) {
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view.file === currentFile) {
          activeView = view;
          this.debug("Found view for current file in Print Mode");
          break;
        }
      }
    }
    const commentsLeaves = this.app.workspace.getLeavesOfType(COMMENTS_VIEW_TYPE);
    if (!activeView && commentsLeaves.length > 0) {
      const commentsView = commentsLeaves[0].view;
      if (commentsView.currentFile) {
        currentFile = commentsView.currentFile;
        this.debug("Using stored current file from comments view");
        const leaves = this.app.workspace.getLeavesOfType("markdown");
        for (const leaf of leaves) {
          const view = leaf.view;
          if (view.file === currentFile) {
            activeView = view;
            this.debug("Found view for stored file in Print Mode");
            break;
          }
        }
      }
    }
    if (!activeView) {
      new import_obsidian.Notice("No active markdown file found. Please open a markdown file first.");
      return;
    }
    const content = activeView.editor.getValue();
    if (!content || content.trim().length === 0) {
      new import_obsidian.Notice("The current file is empty");
      return;
    }
    const convertedContent = this.convertCommentsToCallouts(content);
    if (convertedContent === content) {
      new import_obsidian.Notice("No comments found to convert");
      return;
    }
    new PrintModePreviewModal(this.app, this, content, convertedContent, activeView).open();
  }
  convertCommentsToCallouts(content) {
    const comments = this.extractComments(content);
    const headers = this.extractHeaders(content);
    if (comments.length === 0) {
      return content;
    }
    let result = content;
    const sortedComments = [...comments].sort((a, b) => b.startPos - a.startPos);
    for (const comment of sortedComments) {
      const callout = this.createCalloutFromComment(comment, headers);
      const before = result.substring(0, comment.startPos);
      const after = result.substring(comment.endPos);
      result = before + callout + after;
    }
    return result;
  }
  createCalloutFromComment(comment, headers) {
    const calloutType = this.settings.printModeCalloutType;
    let nearestHeader = null;
    for (let i = headers.length - 1; i >= 0; i--) {
      if (headers[i].line < comment.line) {
        nearestHeader = headers[i];
        break;
      }
    }
    let title = "Comment";
    if (nearestHeader) {
      title = `Comment: ${nearestHeader.text}`;
    }
    title += ` (Line ${comment.line + 1})`;
    const commentText = comment.text.split("\n").map((line) => line.trim()).filter((line) => line.length > 0).join("\n> ");
    let callout = `
> [!${calloutType}]+ ${title}
> ${commentText}
`;
    return callout;
  }
  debounceRefresh() {
    this.debug("debounceRefresh called, skipNextRefresh:", this.skipNextRefresh);
    if (this.skipNextRefresh) {
      this.debug("Skipping refresh due to skipNextRefresh flag");
      this.skipNextRefresh = false;
      return;
    }
    if (this.refreshTimeout) {
      window.clearTimeout(this.refreshTimeout);
    }
    this.refreshTimeout = window.setTimeout(() => {
      this.debug("Executing delayed refresh");
      this.refreshCommentsView();
    }, 500);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(COMMENTS_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
      workspace.revealLeaf(leaf);
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: COMMENTS_VIEW_TYPE, active: true });
      }
    }
    this.refreshCommentsView();
  }
  refreshCommentsView() {
    const leaves = this.app.workspace.getLeavesOfType(COMMENTS_VIEW_TYPE);
    leaves.forEach((leaf) => {
      if (leaf.view instanceof CommentsView) {
        leaf.view.refresh();
      }
    });
  }
  extractComments(content) {
    const comments = [];
    const prefix = this.escapeRegex(this.settings.commentPrefix);
    const commentRegex = new RegExp(`${prefix}(.*?)${prefix}`, "gs");
    let match;
    while ((match = commentRegex.exec(content)) !== null) {
      const startPos = match.index;
      const endPos = match.index + match[0].length;
      const commentText = match[1].trim();
      const beforeComment = content.substring(0, startPos);
      const startLine = (beforeComment.match(/\n/g) || []).length;
      comments.push({
        text: commentText,
        line: startLine,
        startPos,
        endPos,
        fullMatch: match[0]
      });
    }
    return comments;
  }
  extractHeaders(content) {
    const lines = content.split("\n");
    const headers = [];
    const headerRegex = /^(#{1,6})\s+(.+)$/;
    lines.forEach((line, lineIndex) => {
      const match = headerRegex.exec(line.trim());
      if (match) {
        headers.push({
          text: match[2].trim(),
          level: match[1].length,
          line: lineIndex
        });
      }
    });
    return headers;
  }
  groupCommentsByHeaders(comments, headers) {
    this.allHeaders = headers;
    const groups = [];
    const sortedHeaders = [...headers].sort((a, b) => a.line - b.line);
    comments.forEach((comment) => {
      let nearestHeader = null;
      for (let i = sortedHeaders.length - 1; i >= 0; i--) {
        if (sortedHeaders[i].line < comment.line) {
          nearestHeader = sortedHeaders[i];
          break;
        }
      }
      let group = groups.find(
        (g) => g.header === null && nearestHeader === null || g.header !== null && nearestHeader !== null && g.header.line === nearestHeader.line
      );
      if (!group) {
        group = {
          header: nearestHeader,
          comments: []
        };
        groups.push(group);
      }
      group.comments.push(comment);
    });
    groups.sort((a, b) => {
      if (a.header === null && b.header === null) return 0;
      if (a.header === null) return -1;
      if (b.header === null) return 1;
      return a.header.line - b.header.line;
    });
    return this.buildHierarchicalGroups(groups);
  }
  buildHierarchicalGroups(flatGroups) {
    const commentGroupsByHeaderLine = /* @__PURE__ */ new Map();
    let noHeaderGroup = null;
    flatGroups.forEach((group) => {
      if (group.header) {
        commentGroupsByHeaderLine.set(group.header.line, group);
      } else {
        noHeaderGroup = group;
      }
    });
    const allGroups = [];
    if (noHeaderGroup) {
      allGroups.push(noHeaderGroup);
    }
    const sortedHeaders = this.allHeaders.sort((a, b) => a.line - b.line);
    sortedHeaders.forEach((header) => {
      const existingGroup = commentGroupsByHeaderLine.get(header.line);
      if (existingGroup) {
        allGroups.push(existingGroup);
      } else {
        allGroups.push({
          header,
          comments: []
        });
      }
    });
    const result = [];
    const stack = [];
    for (const group of allGroups) {
      if (!group.header) {
        result.push(group);
        continue;
      }
      while (stack.length > 0 && stack[stack.length - 1].header.level >= group.header.level) {
        stack.pop();
      }
      if (stack.length > 0) {
        const parent = stack[stack.length - 1];
        if (!parent.children) {
          parent.children = [];
        }
        parent.children.push(group);
        group.parent = parent;
      } else {
        result.push(group);
      }
      stack.push(group);
    }
    return result;
  }
  hasDescendantComments(header, commentGroupsByHeaderLine) {
    return this.allHeaders.some(
      (otherHeader) => otherHeader.line > header.line && otherHeader.level > header.level && commentGroupsByHeaderLine.has(otherHeader.line)
    );
  }
  escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  highlightCommentInEditor(comment) {
    this.debug("highlightCommentInEditor called", comment);
    const file = this.app.workspace.getActiveFile();
    if (!file) {
      new import_obsidian.Notice("No active markdown file");
      return;
    }
    this.app.workspace.getLeaf().openFile(file).then(() => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView) return;
      const editor = activeView.editor;
      const content = editor.getValue();
      const comments = this.extractComments(content);
      let match = comments.find(
        (c) => c.text === comment.text && c.line === comment.line && c.startPos === comment.startPos
      );
      if (!match) {
        match = comments.find(
          (c) => c.text === comment.text && Math.abs(c.line - comment.line) <= 2
        );
      }
      const target = match || comment;
      this.debug("Found target comment:", target);
      const beforeComment = content.substring(0, target.startPos);
      const startLine = (beforeComment.match(/\n/g) || []).length;
      const startLineContent = content.split("\n")[startLine];
      const commentStartInLine = beforeComment.length - beforeComment.lastIndexOf("\n") - 1;
      const prefixLength = this.settings.commentPrefix.length;
      const cursorPos = {
        line: startLine,
        ch: commentStartInLine + prefixLength + (startLineContent.substring(commentStartInLine + prefixLength).match(/^\s*/) || [""])[0].length
      };
      editor.setCursor(cursorPos);
      editor.scrollIntoView(
        { from: cursorPos, to: cursorPos },
        true
      );
      editor.focus();
    });
    this.debug("Setting skipNextRefresh to true");
    this.skipNextRefresh = true;
    setTimeout(() => {
      this.debug("Clearing skipNextRefresh");
      this.skipNextRefresh = false;
    }, 200);
  }
  highlightHeaderInEditor(header) {
    this.debug("highlightHeaderInEditor called", header);
    const file = this.app.workspace.getActiveFile();
    if (!file) {
      new import_obsidian.Notice("No active markdown file");
      return;
    }
    this.app.workspace.getLeaf().openFile(file).then(() => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (!activeView) return;
      const editor = activeView.editor;
      const headers = this.extractHeaders(editor.getValue());
      const match = headers.find((h) => h.text === header.text && h.level === header.level);
      if (!match) return;
      editor.setCursor({ line: match.line, ch: 0 });
      editor.scrollIntoView({ from: { line: match.line, ch: 0 }, to: { line: match.line, ch: 0 } }, true);
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var CommentsView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.currentFile = null;
    this.renderedGroups = [];
    this.isCollapsed = false;
    this.hasManualExpansions = false;
    this.currentViewMode = "outliner";
    this.plugin = plugin;
    this.isCollapsed = plugin.settings.defaultCollapsed;
    this.currentViewMode = plugin.settings.defaultViewMode;
  }
  debug(message, ...args) {
    if (this.plugin.settings.debugMode) {
      console.log(`[Comments View] ${message}`, ...args);
    }
  }
  getViewType() {
    return COMMENTS_VIEW_TYPE;
  }
  getDisplayText() {
    return "Comments";
  }
  getIcon() {
    return "percent";
  }
  async onOpen() {
    this.refresh();
  }
  async onClose() {
  }
  refresh() {
    this.debug("CommentsView.refresh called");
    const container = this.containerEl.children[1];
    container.empty();
    const header = container.createEl("div", { cls: "comments-header" });
    const titleRow = header.createEl("div", { cls: "comments-title-row" });
    titleRow.createEl("h4", { text: "Comments", cls: "comments-title" });
    const controlsContainer = titleRow.createEl("div", { cls: "comments-controls" });
    const viewModeContainer = controlsContainer.createEl("div", { cls: "view-mode-toggle" });
    const outlinerBtn = viewModeContainer.createEl("button", {
      cls: `view-mode-btn ${this.currentViewMode === "outliner" ? "active" : ""}`,
      attr: { title: "Outliner view (grouped by headers)" }
    });
    outlinerBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M9 9h6v6H9z"/></svg>';
    const listBtn = viewModeContainer.createEl("button", {
      cls: `view-mode-btn ${this.currentViewMode === "list" ? "active" : ""}`,
      attr: { title: "List view (flat list of comments)" }
    });
    listBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>';
    const printModeBtn = controlsContainer.createEl("button", {
      cls: "comments-control-btn print-mode-btn",
      attr: { title: "Convert comments to callouts for printing" }
    });
    printModeBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6,9 6,2 18,2 18,9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect x="6" y="14" width="12" height="8"/></svg>';
    const toggleAllBtn = controlsContainer.createEl("button", {
      cls: "comments-toggle-btn",
      attr: { title: "Toggle collapse/expand all sections" }
    });
    const toggleIcon = toggleAllBtn.createEl("span", { cls: "comments-toggle-icon" });
    toggleIcon.innerHTML = this.isCollapsed ? "+" : "-";
    if (this.currentViewMode === "list") {
      toggleAllBtn.style.display = "none";
    }
    const searchContainer = header.createEl("div", { cls: "comments-search-container" });
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      cls: "comments-search-input",
      attr: {
        placeholder: "Search comments...",
        spellcheck: "false"
      }
    });
    const clearSearchBtn = searchContainer.createEl("button", {
      cls: "comments-clear-search",
      attr: { title: "Clear search" }
    });
    clearSearchBtn.innerHTML = "\xD7";
    outlinerBtn.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.switchViewMode("outliner", outlinerBtn, listBtn, toggleAllBtn);
    };
    listBtn.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.switchViewMode("list", outlinerBtn, listBtn, toggleAllBtn);
    };
    setTimeout(() => {
      this.debug("Executing delayed refresh check");
      let activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      let currentFile = this.app.workspace.getActiveFile();
      this.debug("Active view:", !!activeView, "Current file:", !!currentFile);
      if (!activeView && currentFile) {
        const leaves = this.app.workspace.getLeavesOfType("markdown");
        for (const leaf of leaves) {
          const view = leaf.view;
          if (view.file === currentFile) {
            activeView = view;
            this.debug("Found view for current file");
            break;
          }
        }
      }
      if (!activeView && this.currentFile) {
        this.debug("Using stored current file");
        currentFile = this.currentFile;
      }
      if (!activeView && !currentFile) {
        this.debug("No active markdown view or file found");
        container.createEl("div", {
          text: "No active markdown file",
          cls: "comments-empty"
        });
        toggleAllBtn.disabled = true;
        printModeBtn.disabled = true;
        return;
      }
      if (currentFile) {
        this.currentFile = currentFile;
      }
      this.debug("Getting file content");
      let content = "";
      if (activeView) {
        content = activeView.editor.getValue();
        this.debug("Got content from active view");
        this.processComments(content, container, toggleAllBtn, toggleIcon, searchInput, clearSearchBtn, printModeBtn);
      } else if (currentFile) {
        this.app.vault.read(currentFile).then((fileContent) => {
          this.debug("Got content from file read");
          this.processComments(fileContent, container, toggleAllBtn, toggleIcon, searchInput, clearSearchBtn, printModeBtn);
        });
      }
    }, 10);
  }
  switchViewMode(newMode, outlinerBtn, listBtn, toggleAllBtn) {
    this.debug("Switching view mode to:", newMode);
    this.currentViewMode = newMode;
    if (newMode === "outliner") {
      outlinerBtn.addClass("active");
      listBtn.removeClass("active");
      toggleAllBtn.style.display = "flex";
    } else {
      listBtn.addClass("active");
      outlinerBtn.removeClass("active");
      toggleAllBtn.style.display = "none";
    }
    this.plugin.settings.defaultViewMode = newMode;
    this.plugin.saveSettings();
    this.refresh();
  }
  processComments(content, container, toggleBtn, toggleIcon, searchInput, clearSearchBtn, printModeBtn) {
    this.debug("Processing comments for content of length:", content.length);
    const currentStates = /* @__PURE__ */ new Map();
    this.renderedGroups.forEach((rendered) => {
      if (rendered.group.header) {
        const key = `${rendered.group.header.level}-${rendered.group.header.text}`;
        currentStates.set(key, !rendered.group.isCollapsed);
      }
    });
    this.renderedGroups = [];
    const comments = this.plugin.extractComments(content);
    const headers = this.plugin.extractHeaders(content);
    this.debug("Found", comments.length, "comments in view mode:", this.currentViewMode);
    if (comments.length === 0) {
      container.createEl("div", {
        text: "No comments found",
        cls: "comments-empty"
      });
      if (toggleBtn) toggleBtn.disabled = true;
      if (searchInput) searchInput.disabled = true;
      if (printModeBtn) printModeBtn.disabled = true;
      return;
    }
    if (toggleBtn) toggleBtn.disabled = false;
    if (searchInput) searchInput.disabled = false;
    if (printModeBtn) printModeBtn.disabled = false;
    if (printModeBtn) {
      printModeBtn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.plugin.activatePrintMode();
      };
    }
    const commentsList = container.createEl("div", { cls: "comments-list" });
    if (toggleBtn && toggleIcon && this.currentViewMode === "outliner") {
      const commentGroups = this.plugin.groupCommentsByHeaders(comments, headers);
      const allGroups = [];
      const collectAllGroups = (groups) => {
        groups.forEach((group) => {
          allGroups.push(group);
          if (group.children) {
            collectAllGroups(group.children);
          }
        });
      };
      collectAllGroups(commentGroups);
      toggleBtn.onclick = (e) => {
        this.debug("Toggle button clicked, current state:", this.isCollapsed);
        e.preventDefault();
        e.stopPropagation();
        this.toggleAllGroups(toggleIcon);
      };
      this.updateToggleButton(toggleIcon);
    }
    if (searchInput && clearSearchBtn) {
      let searchTimeout = null;
      let currentSearchTerm = "";
      const performSearch = () => {
        const searchTerm = searchInput.value.toLowerCase().trim();
        currentSearchTerm = searchTerm;
        if (this.currentViewMode === "outliner") {
          const commentGroups = this.plugin.groupCommentsByHeaders(comments, headers);
          this.filterComments(commentsList, commentGroups, searchTerm);
        } else {
          this.filterListComments(commentsList, comments, searchTerm);
        }
        if (searchTerm) {
          clearSearchBtn.style.display = "block";
        } else {
          clearSearchBtn.style.display = "none";
        }
      };
      this.currentSearchTerm = "";
      searchInput.addEventListener("input", () => {
        if (searchTimeout) {
          window.clearTimeout(searchTimeout);
        }
        searchTimeout = window.setTimeout(() => {
          this.currentSearchTerm = searchInput.value.toLowerCase().trim();
          performSearch();
        }, 300);
      });
      clearSearchBtn.addEventListener("click", () => {
        searchInput.value = "";
        this.currentSearchTerm = "";
        performSearch();
        searchInput.focus();
      });
      clearSearchBtn.style.display = "none";
    }
    if (this.currentViewMode === "outliner") {
      this.renderOutlinerView(comments, headers, commentsList, currentStates);
    } else {
      this.renderListView(comments, commentsList);
    }
  }
  renderOutlinerView(comments, headers, commentsList, currentStates) {
    const commentGroups = this.plugin.groupCommentsByHeaders(comments, headers);
    commentGroups.forEach((group) => {
      if (this.isCollapsed && !this.hasManualExpansions) {
        this.setGroupCollapsedRecursively(group, true);
      }
      this.renderCommentGroup(group, commentsList, 0);
    });
    if (this.hasManualExpansions && currentStates.size > 0) {
      this.restoreExpansionStates(commentGroups, currentStates);
    }
    this.debug("Rendered groups count:", this.renderedGroups.length);
    this.debug("Initial collapsed state:", this.isCollapsed, "hasManualExpansions:", this.hasManualExpansions);
  }
  renderListView(comments, commentsList) {
    this.debug("Rendering list view with", comments.length, "comments");
    const sortedComments = [...comments].sort((a, b) => a.line - b.line);
    const listContainer = commentsList.createEl("div", { cls: "comments-list-flat" });
    sortedComments.forEach((comment, index) => {
      this.createListCommentElement(comment, listContainer, index + 1);
    });
  }
  createListCommentElement(comment, container, commentNumber) {
    const commentEl = container.createEl("div", { cls: "comment-item comment-list-item" });
    const headerEl = commentEl.createEl("div", { cls: "comment-list-header" });
    const numberEl = headerEl.createEl("span", {
      text: `${commentNumber}`,
      cls: "comment-list-number"
    });
    const lineEl = headerEl.createEl("span", {
      text: `Line ${comment.line + 1}`,
      cls: "comment-list-line"
    });
    const contentEl = commentEl.createEl("div", { cls: "comment-content" });
    const isMultiLine = comment.text.includes("\n");
    let textEl;
    if (isMultiLine) {
      textEl = contentEl.createEl("textarea", {
        cls: "comment-text comment-textarea",
        attr: {
          spellcheck: "false",
          rows: (comment.text.split("\n").length + 1).toString()
        }
      });
      textEl.value = comment.text || "";
    } else {
      textEl = contentEl.createEl("div", {
        cls: "comment-text",
        attr: { contenteditable: "true", spellcheck: "false" }
      });
      textEl.textContent = comment.text || "(empty comment)";
    }
    const currentSearchTerm = this.currentSearchTerm || "";
    if (currentSearchTerm && comment.text.toLowerCase().includes(currentSearchTerm) && !isMultiLine) {
      if (textEl.tagName === "DIV") {
        textEl.innerHTML = this.highlightSearchText(comment.text || "(empty comment)", currentSearchTerm);
      }
    }
    const actionsEl = commentEl.createEl("div", { cls: "comment-actions" });
    const saveBtn = actionsEl.createEl("button", {
      text: "Save",
      cls: "comment-btn comment-save-btn"
    });
    saveBtn.style.display = "none";
    const cancelBtn = actionsEl.createEl("button", {
      text: "Cancel",
      cls: "comment-btn comment-cancel-btn"
    });
    cancelBtn.style.display = "none";
    const convertBtn = actionsEl.createEl("button", {
      cls: "comment-btn comment-convert-btn",
      attr: { title: "Convert to callout" }
    });
    convertBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>';
    const deleteBtn = actionsEl.createEl("button", {
      text: "\xD7",
      cls: "comment-btn comment-delete-btn",
      attr: { title: "Delete comment" }
    });
    this.setupCommentElementEvents(commentEl, textEl, comment, saveBtn, cancelBtn, convertBtn, deleteBtn, currentSearchTerm);
  }
  filterListComments(commentsList, comments, searchTerm) {
    commentsList.empty();
    if (!searchTerm) {
      this.renderListView(comments, commentsList.parentElement);
      return;
    }
    const filteredComments = comments.filter(
      (comment) => comment.text.toLowerCase().includes(searchTerm)
    );
    if (filteredComments.length === 0) {
      commentsList.createEl("div", {
        text: "No matching comments found",
        cls: "comments-empty"
      });
      return;
    }
    const listContainer = commentsList.createEl("div", { cls: "comments-list-flat" });
    const sortedComments = [...filteredComments].sort((a, b) => a.line - b.line);
    sortedComments.forEach((comment, index) => {
      this.createListCommentElement(comment, listContainer, index + 1);
    });
  }
  setupCommentElementEvents(commentEl, textEl, comment, saveBtn, cancelBtn, convertBtn, deleteBtn, currentSearchTerm) {
    convertBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      new CommentConversionModal(this.app, comment, (customTitle) => {
        this.convertCommentToCallout(comment, customTitle);
      }).open();
    });
    let originalText = comment.text;
    let isEditing = false;
    const handleInput = () => {
      if (!isEditing) {
        isEditing = true;
        saveBtn.style.display = "inline-block";
        cancelBtn.style.display = "inline-block";
        deleteBtn.style.display = "none";
        commentEl.addClass("comment-editing");
      }
    };
    if (textEl.tagName === "TEXTAREA") {
      textEl.addEventListener("input", handleInput);
      const autoResize = () => {
        const textarea = textEl;
        textarea.style.height = "auto";
        textarea.style.height = textarea.scrollHeight + "px";
      };
      textEl.addEventListener("input", autoResize);
      setTimeout(autoResize, 0);
    } else {
      textEl.addEventListener("input", handleInput);
    }
    const handleKeydown = (e) => {
      if (e.key === "Enter" && !e.shiftKey && textEl.tagName !== "TEXTAREA") {
        e.preventDefault();
        saveComment();
      } else if (e.key === "Enter" && e.ctrlKey && textEl.tagName === "TEXTAREA") {
        e.preventDefault();
        saveComment();
      } else if (e.key === "Escape") {
        e.preventDefault();
        cancelEdit();
      }
    };
    textEl.addEventListener("keydown", handleKeydown);
    const saveComment = () => {
      var _a;
      let newText;
      if (textEl.tagName === "TEXTAREA") {
        newText = textEl.value.trim();
      } else {
        newText = ((_a = textEl.textContent) == null ? void 0 : _a.trim()) || "";
      }
      if (newText !== originalText) {
        this.updateCommentInEditor(comment, newText);
        originalText = newText;
      }
      exitEditMode();
    };
    const cancelEdit = () => {
      if (textEl.tagName === "TEXTAREA") {
        textEl.value = originalText;
      } else {
        if (currentSearchTerm && originalText.toLowerCase().includes(currentSearchTerm)) {
          textEl.innerHTML = this.highlightSearchText(originalText, currentSearchTerm);
        } else {
          textEl.textContent = originalText;
        }
      }
      exitEditMode();
    };
    const exitEditMode = () => {
      isEditing = false;
      saveBtn.style.display = "none";
      cancelBtn.style.display = "none";
      deleteBtn.style.display = "inline-block";
      commentEl.removeClass("comment-editing");
      textEl.blur();
    };
    saveBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      saveComment();
    });
    cancelBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      cancelEdit();
    });
    deleteBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const confirmDelete = confirm(`Are you sure you want to delete this comment?

"${comment.text.length > 100 ? comment.text.substring(0, 100) + "..." : comment.text}"`);
      if (confirmDelete) {
        this.deleteCommentFromEditor(comment);
      }
    });
    commentEl.addEventListener("click", (e) => {
      this.debug("Comment clicked, isEditing:", isEditing, "target:", e.target);
      if (isEditing) return;
      const target = e.target;
      if (target.tagName === "BUTTON" || target.closest("button")) {
        this.debug("Click was on button, ignoring");
        return;
      }
      if (target === textEl) {
        this.debug("Clicked on text element, entering edit mode");
        e.preventDefault();
        e.stopPropagation();
        isEditing = true;
        saveBtn.style.display = "inline-block";
        cancelBtn.style.display = "inline-block";
        deleteBtn.style.display = "none";
        commentEl.addClass("comment-editing");
        textEl.focus();
        if (textEl.tagName === "TEXTAREA") {
          textEl.select();
        } else {
          const range = document.createRange();
          range.selectNodeContents(textEl);
          const selection = window.getSelection();
          if (selection) {
            selection.removeAllRanges();
            selection.addRange(range);
          }
        }
        return;
      }
      this.debug("Calling highlightCommentInEditor");
      e.preventDefault();
      e.stopPropagation();
      this.plugin.skipNextRefresh = true;
      this.plugin.highlightCommentInEditor(comment);
      setTimeout(() => {
        this.plugin.skipNextRefresh = false;
      }, 300);
    });
    commentEl.addEventListener("mouseleave", () => {
      commentEl.removeClass("comment-item-hover");
    });
  }
  restoreExpansionStates(groups, states) {
    const restoreGroup = (group) => {
      if (group.header) {
        const key = `${group.header.level}-${group.header.text}`;
        const wasExpanded = states.get(key);
        if (wasExpanded !== void 0) {
          group.isCollapsed = !wasExpanded;
          const rendered = this.renderedGroups.find(
            (r) => r.group.header && r.group.header.level === group.header.level && r.group.header.text === group.header.text
          );
          if (rendered) {
            rendered.collapseIcon.textContent = group.isCollapsed ? "\u25B6" : "\u25BC";
            rendered.contentElement.style.display = group.isCollapsed ? "none" : "block";
          }
        }
      }
      if (group.children) {
        group.children.forEach(restoreGroup);
      }
    };
    groups.forEach(restoreGroup);
  }
  setGroupCollapsedRecursively(group, collapsed) {
    group.isCollapsed = collapsed;
    if (group.children) {
      group.children.forEach((child) => {
        this.setGroupCollapsedRecursively(child, collapsed);
      });
    }
  }
  highlightSearchText(text, searchTerm) {
    if (!searchTerm) return text;
    const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")})`, "gi");
    return text.replace(regex, '<mark class="search-highlight">$1</mark>');
  }
  filterComments(commentsList, commentGroups, searchTerm) {
    commentsList.empty();
    if (!searchTerm) {
      commentGroups.forEach((group) => {
        this.renderCommentGroup(group, commentsList, 0);
      });
      return;
    }
    const filteredGroups = this.filterGroupsRecursively(commentGroups, searchTerm);
    if (filteredGroups.length === 0) {
      commentsList.createEl("div", {
        text: "No matching comments found",
        cls: "comments-empty"
      });
      return;
    }
    filteredGroups.forEach((group) => {
      this.renderCommentGroup(group, commentsList, 0);
    });
  }
  filterGroupsRecursively(groups, searchTerm) {
    const filtered = [];
    groups.forEach((group) => {
      var _a;
      const headerMatches = ((_a = group.header) == null ? void 0 : _a.text.toLowerCase().includes(searchTerm)) || false;
      const matchingComments = group.comments.filter(
        (comment) => comment.text.toLowerCase().includes(searchTerm)
      );
      const filteredChildren = group.children ? this.filterGroupsRecursively(group.children, searchTerm) : [];
      if (headerMatches || matchingComments.length > 0 || filteredChildren.length > 0) {
        const filteredGroup = {
          header: group.header,
          comments: headerMatches ? group.comments : matchingComments,
          children: filteredChildren.length > 0 ? filteredChildren : void 0,
          parent: group.parent,
          isCollapsed: false
        };
        filtered.push(filteredGroup);
      }
    });
    return filtered;
  }
  renderCommentGroup(group, container, depth) {
    const headerSection = container.createEl("div", { cls: "comment-header-section" });
    headerSection.style.marginLeft = `${depth * 12}px`;
    const headerEl = headerSection.createEl("div", { cls: "comment-header" });
    const collapseIcon = headerEl.createEl("span", { cls: "comment-collapse-icon" });
    const hasChildren = group.children && group.children.length > 0 || group.comments.length > 0;
    if (hasChildren) {
      collapseIcon.textContent = group.isCollapsed ? "\u25B6" : "\u25BC";
      collapseIcon.style.visibility = "visible";
    } else {
      collapseIcon.style.visibility = "hidden";
    }
    const headerText = headerEl.createEl("span", { cls: "comment-header-text" });
    if (group.header) {
      const totalComments = this.countTotalComments(group);
      if (totalComments > 0) {
        headerText.textContent = `${group.header.text} (${totalComments})`;
      } else {
        headerText.textContent = group.header.text;
      }
    } else {
      headerText.textContent = `No Header (${group.comments.length})`;
    }
    const groupContent = headerSection.createEl("div", { cls: "comment-group-content" });
    if (group.isCollapsed) {
      groupContent.style.display = "none";
    }
    if (hasChildren) {
      this.renderedGroups.push({
        group,
        collapseIcon,
        contentElement: groupContent
      });
    }
    if (hasChildren) {
      collapseIcon.addEventListener("click", (e) => {
        var _a;
        this.debug("Collapse icon clicked for group:", ((_a = group.header) == null ? void 0 : _a.text) || "No Header");
        e.preventDefault();
        e.stopPropagation();
        this.toggleGroupCollapse(group, collapseIcon, groupContent);
      });
    }
    if (group.header) {
      headerText.addEventListener("click", (e) => {
        this.debug("Header text clicked, navigating to:", group.header.text);
        e.preventDefault();
        e.stopPropagation();
        this.plugin.skipNextRefresh = true;
        this.plugin.highlightHeaderInEditor(group.header);
        setTimeout(() => {
          this.plugin.skipNextRefresh = false;
        }, 100);
        return false;
      });
      headerEl.addEventListener("click", (e) => {
        if (e.target === collapseIcon || e.target === headerText) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
    }
    if (group.comments.length > 0) {
      const groupComments = groupContent.createEl("div", { cls: "comment-group-comments" });
      group.comments.forEach((comment) => {
        this.createCommentElement(comment, groupComments);
      });
    }
    if (group.children) {
      group.children.forEach((childGroup) => {
        this.renderCommentGroup(childGroup, groupContent, depth + 1);
      });
    }
  }
  countTotalComments(group) {
    let total = group.comments.length;
    if (group.children) {
      group.children.forEach((child) => {
        total += this.countTotalComments(child);
      });
    }
    return total;
  }
  toggleGroupCollapse(group, icon, content) {
    group.isCollapsed = !group.isCollapsed;
    if (group.isCollapsed) {
      icon.textContent = "\u25B6";
      content.style.display = "none";
    } else {
      icon.textContent = "\u25BC";
      content.style.display = "block";
      this.hasManualExpansions = true;
    }
    if (group.isCollapsed && group.children) {
      this.collapseAllChildren(group);
    }
    this.debug("Group toggled, hasManualExpansions:", this.hasManualExpansions);
  }
  toggleAllGroups(toggleIcon) {
    this.debug("toggleAllGroups called, current state:", this.isCollapsed);
    if (this.isCollapsed) {
      this.debug("Expanding all groups");
      this.expandAllGroups([]);
      this.hasManualExpansions = false;
    } else {
      this.debug("Collapsing all groups to top level overview");
      this.collapseAllGroups([]);
      this.hasManualExpansions = false;
    }
    this.isCollapsed = !this.isCollapsed;
    this.updateToggleButton(toggleIcon);
    this.debug("toggleAllGroups completed, new state:", this.isCollapsed);
  }
  updateToggleButton(toggleIcon) {
    if (this.isCollapsed) {
      toggleIcon.innerHTML = "+";
      toggleIcon.parentElement.setAttribute("title", "Expand all sections");
    } else {
      toggleIcon.innerHTML = "-";
      toggleIcon.parentElement.setAttribute("title", "Collapse all sections");
    }
  }
  collapseAllGroups(allGroups) {
    this.debug("Collapsing all groups to top level overview");
    this.renderedGroups.forEach((rendered) => {
      const hasContent = rendered.group.children && rendered.group.children.length > 0 || rendered.group.comments.length > 0;
      if (hasContent) {
        rendered.group.isCollapsed = true;
        rendered.collapseIcon.textContent = "\u25B6";
        rendered.contentElement.style.display = "none";
      }
    });
  }
  expandAllGroups(allGroups) {
    this.debug("Expanding all groups");
    this.renderedGroups.forEach((rendered) => {
      rendered.group.isCollapsed = false;
      rendered.collapseIcon.textContent = "\u25BC";
      rendered.contentElement.style.display = "block";
    });
  }
  collapseAllChildren(group) {
    if (group.children) {
      group.children.forEach((child) => {
        child.isCollapsed = true;
        this.collapseAllChildren(child);
      });
    }
  }
  createCommentElement(comment, container) {
    const commentEl = container.createEl("div", { cls: "comment-item" });
    const contentEl = commentEl.createEl("div", { cls: "comment-content" });
    const isMultiLine = comment.text.includes("\n");
    let textEl;
    if (isMultiLine) {
      textEl = contentEl.createEl("textarea", {
        cls: "comment-text comment-textarea",
        attr: {
          spellcheck: "false",
          rows: (comment.text.split("\n").length + 1).toString()
        }
      });
      textEl.value = comment.text || "";
    } else {
      textEl = contentEl.createEl("div", {
        cls: "comment-text",
        attr: { contenteditable: "true", spellcheck: "false" }
      });
      textEl.textContent = comment.text || "(empty comment)";
    }
    const currentSearchTerm = this.currentSearchTerm || "";
    if (currentSearchTerm && comment.text.toLowerCase().includes(currentSearchTerm) && !isMultiLine) {
      if (textEl.tagName === "DIV") {
        textEl.innerHTML = this.highlightSearchText(comment.text || "(empty comment)", currentSearchTerm);
      }
    }
    const lineEl = contentEl.createEl("div", {
      text: `Line ${comment.line + 1}`,
      cls: "comment-line"
    });
    const actionsEl = commentEl.createEl("div", { cls: "comment-actions" });
    const saveBtn = actionsEl.createEl("button", {
      text: "Save",
      cls: "comment-btn comment-save-btn"
    });
    saveBtn.style.display = "none";
    const cancelBtn = actionsEl.createEl("button", {
      text: "Cancel",
      cls: "comment-btn comment-cancel-btn"
    });
    cancelBtn.style.display = "none";
    const convertBtn = actionsEl.createEl("button", {
      cls: "comment-btn comment-convert-btn",
      attr: { title: "Convert to callout" }
    });
    convertBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>';
    const deleteBtn = actionsEl.createEl("button", {
      text: "\xD7",
      cls: "comment-btn comment-delete-btn",
      attr: { title: "Delete comment" }
    });
    this.setupCommentElementEvents(commentEl, textEl, comment, saveBtn, cancelBtn, convertBtn, deleteBtn, currentSearchTerm);
  }
  updateCommentInEditor(comment, newText) {
    this.debug("updateCommentInEditor called with:", newText);
    let activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    let currentFile = this.app.workspace.getActiveFile();
    this.debug("Active view:", !!activeView, "Current file:", !!currentFile);
    if (!activeView && currentFile) {
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view.file === currentFile) {
          activeView = view;
          this.debug("Found view for current file in update");
          break;
        }
      }
    }
    if (!activeView && this.currentFile) {
      this.debug("Using stored current file for update");
      currentFile = this.currentFile;
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view.file === currentFile) {
          activeView = view;
          this.debug("Found view for stored file in update");
          break;
        }
      }
    }
    if (!activeView) {
      this.debug("No active view found for updating comment");
      return;
    }
    this.debug("Found active view, proceeding with update");
    const editor = activeView.editor;
    const currentContent = editor.getValue();
    this.debug("Current content length:", currentContent.length);
    this.debug("Original comment:", comment);
    const currentComments = this.plugin.extractComments(currentContent);
    const matchingComment = currentComments.find(
      (c) => c.text === comment.text && c.line === comment.line
    );
    if (!matchingComment) {
      this.debug("Could not find matching comment in current content");
      const textMatch = currentComments.find((c) => c.text === comment.text);
      if (textMatch) {
        this.debug("Found comment by text match");
        this.performCommentUpdate(editor, textMatch, newText);
      } else {
        this.debug("Comment not found, it may have been deleted");
        this.refresh();
      }
      return;
    }
    this.debug("Found matching comment with current positions:", matchingComment);
    this.performCommentUpdate(editor, matchingComment, newText);
  }
  performCommentUpdate(editor, comment, newText) {
    const content = editor.getValue();
    const beforeComment = content.substring(0, comment.startPos);
    const afterComment = content.substring(comment.endPos);
    const newComment = `${this.plugin.settings.commentPrefix} ${newText} ${this.plugin.settings.commentPrefix}`;
    this.debug("Replacing comment at positions", comment.startPos, "-", comment.endPos);
    this.debug("Old comment:", comment.fullMatch);
    this.debug("New comment:", newComment);
    const newContent = beforeComment + newComment + afterComment;
    editor.setValue(newContent);
    new import_obsidian.Notice("Comment updated");
    setTimeout(() => {
      this.debug("Refreshing view after comment update");
      this.refresh();
    }, 100);
  }
  deleteCommentFromEditor(comment) {
    this.debug("deleteCommentFromEditor called for:", comment);
    let activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    let currentFile = this.app.workspace.getActiveFile();
    this.debug("Delete - Active view:", !!activeView, "Current file:", !!currentFile);
    if (!activeView && currentFile) {
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view.file === currentFile) {
          activeView = view;
          this.debug("Found view for current file in delete");
          break;
        }
      }
    }
    if (!activeView && this.currentFile) {
      this.debug("Using stored current file for delete");
      currentFile = this.currentFile;
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view.file === currentFile) {
          activeView = view;
          this.debug("Found view for stored file in delete");
          break;
        }
      }
    }
    if (!activeView) {
      this.debug("No active view found for deleting comment");
      return;
    }
    const editor = activeView.editor;
    const currentContent = editor.getValue();
    const currentComments = this.plugin.extractComments(currentContent);
    const matchingComment = currentComments.find(
      (c) => c.text === comment.text && c.line === comment.line
    );
    if (!matchingComment) {
      this.debug("Could not find matching comment to delete");
      this.refresh();
      return;
    }
    this.debug("Deleting comment at positions", matchingComment.startPos, "-", matchingComment.endPos);
    const beforeComment = currentContent.substring(0, matchingComment.startPos);
    const afterComment = currentContent.substring(matchingComment.endPos);
    const newContent = beforeComment + afterComment;
    const finalContent = newContent.replace(/  +/g, " ");
    editor.setValue(finalContent);
    new import_obsidian.Notice("Comment deleted");
    setTimeout(() => {
      this.debug("Refreshing view after comment deletion");
      this.refresh();
    }, 100);
  }
  convertCommentToCallout(comment, customTitle) {
    this.debug("convertCommentToCallout called for:", comment, "with title:", customTitle);
    let activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    let currentFile = this.app.workspace.getActiveFile();
    this.debug("Convert - Active view:", !!activeView, "Current file:", !!currentFile);
    if (!activeView && currentFile) {
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view.file === currentFile) {
          activeView = view;
          this.debug("Found view for current file in convert");
          break;
        }
      }
    }
    if (!activeView && this.currentFile) {
      this.debug("Using stored current file for convert");
      currentFile = this.currentFile;
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view.file === currentFile) {
          activeView = view;
          this.debug("Found view for stored file in convert");
          break;
        }
      }
    }
    if (!activeView) {
      this.debug("No active view found for converting comment");
      return;
    }
    const editor = activeView.editor;
    const currentContent = editor.getValue();
    const currentComments = this.plugin.extractComments(currentContent);
    const matchingComment = currentComments.find(
      (c) => c.text === comment.text && c.line === comment.line
    );
    if (!matchingComment) {
      this.debug("Could not find matching comment to convert");
      this.refresh();
      return;
    }
    const headers = this.plugin.extractHeaders(currentContent);
    const callout = this.createCalloutFromComment(matchingComment, headers, customTitle);
    this.debug("Converting comment at positions", matchingComment.startPos, "-", matchingComment.endPos);
    this.debug("Original comment:", matchingComment.fullMatch);
    this.debug("New callout:", callout);
    const beforeComment = currentContent.substring(0, matchingComment.startPos);
    const afterComment = currentContent.substring(matchingComment.endPos);
    const newContent = beforeComment + callout + afterComment;
    editor.setValue(newContent);
    editor.refresh();
    const titleText = customTitle ? `"${customTitle}"` : "callout";
    new import_obsidian.Notice(`Comment converted to ${titleText}`);
    setTimeout(() => {
      this.debug("Refreshing view after comment conversion");
      this.refresh();
    }, 100);
  }
  createCalloutFromComment(comment, headers, customTitle) {
    const calloutType = this.plugin.settings.printModeCalloutType;
    let title;
    if (customTitle && customTitle.trim().length > 0) {
      title = customTitle.trim();
    } else {
      let nearestHeader = null;
      for (let i = headers.length - 1; i >= 0; i--) {
        if (headers[i].line < comment.line) {
          nearestHeader = headers[i];
          break;
        }
      }
      title = "Comment";
      if (nearestHeader) {
        title = `Comment: ${nearestHeader.text}`;
      }
      title += ` (Line ${comment.line + 1})`;
    }
    const commentText = comment.text.split("\n").map((line) => line.trim()).filter((line) => line.length > 0).join("\n> ");
    let callout = `
> [!${calloutType}]+ ${title}
> ${commentText}
`;
    return callout;
  }
};
var CommentsManagerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Comments Manager Settings" });
    new import_obsidian.Setting(containerEl).setName("Comment prefix").setDesc("The characters used to mark comments (e.g., %% for Obsidian comments)").addText((text) => text.setPlaceholder("%%").setValue(this.plugin.settings.commentPrefix).onChange(async (value) => {
      this.plugin.settings.commentPrefix = value || "%%";
      await this.plugin.saveSettings();
      this.plugin.refreshCommentsView();
    }));
    new import_obsidian.Setting(containerEl).setName("Open panel on startup").setDesc("Automatically open the comments panel when Obsidian starts").addToggle((toggle) => toggle.setValue(this.plugin.settings.openOnStart).onChange(async (value) => {
      this.plugin.settings.openOnStart = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default view mode").setDesc("Choose the default view mode for the comments panel").addDropdown((dropdown) => dropdown.addOption("outliner", "Outliner (grouped by headers)").addOption("list", "List (flat list of comments)").setValue(this.plugin.settings.defaultViewMode).onChange(async (value) => {
      this.plugin.settings.defaultViewMode = value;
      await this.plugin.saveSettings();
      this.plugin.refreshCommentsView();
    }));
    new import_obsidian.Setting(containerEl).setName("Default collapsed view").setDesc("Start with comments panel in collapsed state (applies to outliner view only)").addToggle((toggle) => toggle.setValue(this.plugin.settings.defaultCollapsed).onChange(async (value) => {
      this.plugin.settings.defaultCollapsed = value;
      await this.plugin.saveSettings();
      this.plugin.refreshCommentsView();
    }));
    new import_obsidian.Setting(containerEl).setName("Debug mode").setDesc("Enable debug logging in the developer console (for troubleshooting)").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
      this.plugin.settings.debugMode = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Print Mode Settings" });
    new import_obsidian.Setting(containerEl).setName("Callout type for print mode").setDesc("The type of callout to use when converting comments (e.g., comment, note, info)").addText((text) => text.setPlaceholder("comment").setValue(this.plugin.settings.printModeCalloutType).onChange(async (value) => {
      this.plugin.settings.printModeCalloutType = value || "comment";
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include comment author").setDesc("Include author information in converted callouts (placeholder for future feature)").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeCommentAuthor).onChange(async (value) => {
      this.plugin.settings.includeCommentAuthor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include comment timestamp").setDesc("Include timestamp information in converted callouts (placeholder for future feature)").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeCommentTimestamp).onChange(async (value) => {
      this.plugin.settings.includeCommentTimestamp = value;
      await this.plugin.saveSettings();
    }));
    const instructionsEl = containerEl.createEl("div", { cls: "print-mode-instructions" });
    instructionsEl.createEl("h4", { text: "View Modes:" });
    const viewModesList = instructionsEl.createEl("ul");
    viewModesList.createEl("li", { text: "Outliner View: Comments are grouped under their nearest preceding header in a hierarchical tree structure" });
    viewModesList.createEl("li", { text: "List View: Comments are shown in a flat list in document order, without any grouping" });
    instructionsEl.createEl("h4", { text: "How to use Print Mode:" });
    const instructionsList = instructionsEl.createEl("ol");
    instructionsList.createEl("li", { text: 'Click the printer icon button in the Comments panel or use the command "Activate Print Mode"' });
    instructionsList.createEl("li", { text: "Preview how your document will look with comments converted to callouts" });
    instructionsList.createEl("li", { text: 'Click "Export to PDF" to trigger PDF export with converted comments' });
    instructionsList.createEl("li", { text: "Your original document remains unchanged - comments are converted temporarily" });
  }
};
